<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>H40N - N.ROOT | TERMINAL V3.3</title>
<style>
    :root{
        --bg:#0a0a0a;
        --panel:#111;
        --panel-2:#1a1a1a;
        --text:#e5e5e5;
        --muted:#9aa4ac;
        --accent:#4ecbff;
        --prompt:#00e676;
        --user:#6ac8ff;
        --admin:#e5e5e5;
    }
    html,body{
        height:100%;
        margin:0;
        background:var(--bg);
        font-family:monospace;
        color:var(--text);
    }
    .terminal-wrapper{
        width:92%;
        max-width:980px;
        margin:28px auto;
        border-radius:10px;
        overflow:hidden;
        border:1px solid #222;
        box-shadow:0 10px 50px rgba(0,0,0,0.7);
        background:linear-gradient(180deg,var(--panel),#0f0f0f);
    }
    .terminal-header{
        display:flex;
        align-items:center;
        gap:10px;
        padding:12px;
        background:var(--panel-2);
        border-bottom:1px solid #222
    }
    .dot{
        width:12px;
        height:12px;
        border-radius:50%
    }
    .red{background:#ff5f56}
    .yellow{background:#ffbd2e}
    .green{background:#27c93f}
    
    .terminal-title{
        flex:1;
        text-align:center;
        opacity:.85;
        font-size:0.95rem
    }
    #output{
        height:68vh;
        padding:20px;
        overflow-y:auto;
        white-space:pre-wrap;
        line-height:1.35;
        font-size:0.98rem
    }
    .terminal-input-area{
        display:flex;
        align-items:center;
        gap:10px;
        padding:12px;
        background:var(--panel-2);
        border-top:1px solid #222
    }
    #prompt{color:var(--prompt);font-weight:700}
    /* fake input box (disabled) */
    .input-disabled{
        flex:1;
        padding:10px 12px;
        border-radius:6px;
        border:1px dashed #2b2b2b;
        background:transparent;
        color:var(--muted);
        font-family:monospace;
        font-size:0.95rem;
    }
    .note-strong{color:#ff9aa2;font-weight:700}
    .line{margin:6px 0}
    .meta{color:var(--muted)}
    .user-NOAH{color:#3ee9e9}
    .user-ECH0{color:#ffa200}
    .admin-msg{color:var(--admin)}
    .process{color:#ffdb25}
    .sucess{color:#00e676}

    /* typing caret for lines being typed */
    .typing-caret::after{
        content: "|";
        display:inline-block;
        margin-left:6px;
        animation: blink 1s steps(2,start) infinite;
        color:var(--text);
    }
    @keyframes blink{50%{opacity:0}}
    /* small emphasis */
    .em{color:var(--accent)}
    /* scrollbar cosmetic */
    #output::-webkit-scrollbar{width:10px}
    #output::-webkit-scrollbar-thumb{background:#111;border-radius:6px}

    .gap {
    height: 22px;     /* tamanho visual do salto */
    display: block;
    }

    .progress-bar-container {
    width: 100%;
    background: #111;
    border: 1px solid #222;
    border-radius: 6px;
    margin-top: 8px;
    padding: 6px;
    }

    .progress-label {
    margin-top: 4px;
    font-size: 0.85rem;
    color: var(--muted);
    }

    /* animação de "processando" na barra fixa */
    .progress-bar {
        height: 14px;
        width: 0%;
        background: var(--accent);
        border-radius: 4px;
        transition: width 1.6s ease;
        position: relative;
        overflow: hidden;
    }

    /* efeito de brilho se movendo dentro da barra */
    .progress-bar::after {
        content: "";
        position: absolute;
        top: 0;
        left: -40%;
        width: 40%;
        height: 100%;
        background: linear-gradient(
            90deg,
            transparent,
            rgba(255,255,255,0.35),
            transparent
        );
        animation: barShine 1.4s infinite linear;
        mix-blend-mode: screen;
    }

    @keyframes barShine {
        0% { left: -40%; }
        100% { left: 140%; }
    }

    .fade-out {
    opacity: 0;
    transition: opacity 0.45s ease;
    }

</style>
</head>
<body>
<div class="terminal-wrapper" role="region" aria-label="Contingency Terminal">
    <div class="terminal-header">
        <div class="dot red"></div>
        <div class="dot yellow"></div>
        <div class="dot green"></div>
        <div class="terminal-title">H40N - N.ROOT | TERMINAL V3.3</div>
    </div>

    <div id="output" aria-live="polite"></div>

    <div class="terminal-input-area" aria-hidden="true">
        <div id="prompt">&gt;</div>
        <!-- área onde usuário podia digitar: permissão removida -->
        <div class="input-disabled" title="Escrita desativada">
            &nbsp;Não é possível inserir comandos agora.
        </div>
    </div>
</div>

<script>
const output = document.getElementById('output');

let progressBarFixed = null;
let hasShownFirstBar = false;

// ----- FUNÇÃO: cria barra fixa ou atualiza -----
// -----------------------------
// SISTEMA DE PROGRESSO AUTOMÁTICO
// -----------------------------
let progressValue = 50;  // valor inicial da barra
let autoProgressInterval = null;

// cria/atualiza a barra fixa
function updateFixedProgress(val) {
    progressValue = Math.max(0, Math.min(val, 100)); //

    if (!progressBarFixed) {
        progressBarFixed = document.createElement("div");
        progressBarFixed.className = "progress-bar-container";

        const bar = document.createElement("div");
        bar.className = "progress-bar";
        bar.style.width = progressValue + "%";

        const label = document.createElement("div");
        label.className = "progress-label";
        label.textContent = `Reiniciando sistema... ${progressValue}%`;

        progressBarFixed.appendChild(bar);
        progressBarFixed.appendChild(label);
        output.appendChild(progressBarFixed);
    } else {
        const bar = progressBarFixed.querySelector(".progress-bar");
        const label = progressBarFixed.querySelector(".progress-label");

        bar.style.width = progressValue + "%";
        label.textContent = `Reiniciando sistema... ${progressValue}%`;
    }
}
function animateInitialProgress(toValue = 50) {
    return new Promise(resolve => {
        let current = 0;

        const interval = setInterval(() => {
            if (current >= toValue) {
                clearInterval(interval);
                updateFixedProgress(toValue);
                resolve();
                return;
            }

            current++;
            updateFixedProgress(current);

        }, 40); // velocidade da subida inicial (40ms entre steps → ~2s total)
    });
}

function tacticalBar(label, percent) {
    const total = 12;

    // calcula quantos blocos preenchidos
    const filled = Math.floor((percent / 100) * total);
    const empty = total - filled;

    const bar = "▦".repeat(filled) + "▢".repeat(empty);

    return `${label}:     [${bar}] ${percent}%`;
}



// inicia subida automática de 1% a cada 10s
function startAutoProgress() {
    if (autoProgressInterval) return; 

    autoProgressInterval = setInterval(() => {
        if (progressValue < 100) {
    updateFixedProgress(progressValue + 1);
    } else {
    triggerECH0Reset(); // chama a quebra do ECH0
    }

    }, 2000);
}

// reduz porcentagem quando ECH0.inject aparece
function applyECH0Injection(amount) {
    updateFixedProgress(progressValue - amount);
}


// ----- FUNÇÃO: remove linhas ENTRE o índice 8 até antes da barra -----
// (mantive essa função, não usada se você prefere backspace; deixei por segurança)
function removeInitialLines() {
    const children = Array.from(output.children);

    // Mantém tudo até a barra fixa
    const preserveUntil = children.indexOf(progressBarFixed);

    for (let i = preserveUntil - 1; i >= 2; i--) {
        output.removeChild(children[i]);
    }
}

// ----- FUNÇÃO: apaga bloco com animação de backspace -----
async function eraseBlock(lines) {
    for (let i = lines.length - 1; i >= 0; i--) {
        const el = lines[i];

        // aplica fade-out
        el.classList.add("fade-out");

        // espera a transição terminar
        await new Promise(resolve => setTimeout(resolve, 460));

        if (el.parentElement) {
            el.parentElement.removeChild(el);
        }
    }
}

// ===============================================
//    SEGUNDA BARRA — "RECRIANDO TERMINAL"
//    (sem interferência do ECH0)
// ===============================================

let recreationBar = null;
let recreationValue = 0;
let recreationAutoInterval = null;

// =====================
// Contador específico
// =====================
// Target fixo: 20 de dezembro de 2058 (meia-noite local)
const countdownTargetDate = new Date('2058-12-20T00:00:00');

// flag se o contador deve ser exibido (apenas enquanto 'hoje' for 2058-12-20)
let countdownActive = false;
let countdownInterval = null;


// formata restante em "Xd Xh Xm Xs"
function formatRemaining(ms) {
    if (ms <= 0) return "0s";

    const s = Math.floor(ms / 1000);

    const years = Math.floor(s / (86400 * 365));
    const days  = Math.floor((s % (86400 * 365)) / 86400);
    const hours = Math.floor((s % 86400) / 3600);
    const mins  = Math.floor((s % 3600) / 60);
    const secs  = s % 60;

    let parts = [];

    if (years) parts.push(years + "y");
    if (days)  parts.push(days + "d");
    if (hours) parts.push(hours + "h");
    if (mins)  parts.push(mins + "m");
    parts.push(secs + "s");

    return parts.join(" ");
}


// inicia o interval do contador (atualiza a cada 1s)
function startCountdown() {
    if (countdownInterval) return;

    countdownActive = true;

    countdownInterval = setInterval(() => {
        if (!recreationBar) return;

        const now = new Date();
        let remaining = countdownTargetDate - now;

        if (remaining < 0) remaining = 0;

        updateRecreationProgress(recreationValue);

        if (remaining === 0) {
            stopCountdown();
        }
    }, 1000);
}


function stopCountdown() {
    countdownActive = false;
    if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
    }
}


// startRecreationBar agora verifica se hoje é 2058-12-20 e ativa o contador apenas nesse dia.
function startRecreationBar() {
    recreationValue = 0;

    recreationBar = document.createElement("div");
    recreationBar.className = "progress-bar-container";

    const bar = document.createElement("div");
    bar.className = "progress-bar";
    bar.style.width = "0%";

    const label = document.createElement("div");
    label.className = "progress-label";
    label.textContent = "Recriando terminal... 0%";

    recreationBar.appendChild(bar);
    recreationBar.appendChild(label);
    output.appendChild(recreationBar);

    output.scrollTop = output.scrollHeight;

    // contador agora sempre ativo
    startCountdown();


    // animação automática até 30%
    recreationAutoInterval = setInterval(() => {
        if (recreationValue < 30) {
            updateRecreationProgress(recreationValue + 1);
        } else {
            clearInterval(recreationAutoInterval);
            recreationAutoInterval = null;

            // Inicia o texto embutido que atualiza os bytes
            startInlineLoading();

            // Inicia os blocos de conversa
            startRecreationSequence();
        }
    }, 1000);

}

// ===============================================
//   CARREGAMENTO EMBUTIDO NO LABEL DA BARRA 2
// ===============================================

let loadCurrentBytes = 0;
let loadTargetBytes = 10000000 * 1024 * 1024 * 1024; // 10.000.000 GB
let loadInterval = null;

function formatBytes(bytes) {
    const GB = 1024 * 1024 * 1024;
    const MB = 1024 * 1024;
    const KB = 1024;

    if (bytes >= GB) return (bytes / GB).toFixed(2) + " GB";
    if (bytes >= MB) return (bytes / MB).toFixed(2) + " MB";
    if (bytes >= KB) return (bytes / KB).toFixed(2) + " KB";

    return bytes + " B";
}

function startInlineLoading() {
    const label = recreationBar.querySelector(".progress-label");

    loadInterval = setInterval(() => {

        const minStep = 100 * 1024 * 1024;        // 100MB
        const maxStep = 2 * 1024 * 1024 * 1024;  // 2GB
        const inc = Math.random() * (maxStep - minStep) + minStep;

        loadCurrentBytes += inc;

        if (loadCurrentBytes >= loadTargetBytes) {
            loadCurrentBytes = loadTargetBytes;
            clearInterval(loadInterval);
        }

        // Atualiza a label com bytes + porcentagem + (possível) contador
        updateRecreationProgress(recreationValue);

    }, 900);
}


// atualiza a barra de recriação e monta a label completa, incluindo contador quando ativado
function updateRecreationProgress(v) {
    recreationValue = Math.max(0, Math.min(v, 100));

    if (!recreationBar) return;

    const bar = recreationBar.querySelector(".progress-bar");
    const label = recreationBar.querySelector(".progress-label");

    bar.style.width = recreationValue + "%";

    // base do texto com porcentagem
    let text = `Recriando terminal... ${recreationValue}%`;

    // se houver dados de bytes, inclui-os (se startInlineLoading já iniciou, variáveis estarão setadas)
    if (typeof loadCurrentBytes !== "undefined" && loadCurrentBytes > 0) {
        text += ` — ${formatBytes(loadCurrentBytes)} / ${formatBytes(loadTargetBytes)}`;
    }

    // se for o dia-alvo e o contador estiver ativo, adiciona o tempo restante até a data alvo
    if (countdownActive) {
    const now = new Date();
    let remaining = countdownTargetDate - now;
    if (remaining < 0) remaining = 0;

    text += ` — ${formatRemaining(remaining)} restantes`;
    }

    label.textContent = text;
}

// ===============================================
//   Resto do seu código (efeitos de carregamento de arquivos, blocos, etc.)
// ===============================================

async function triggerECH0Reset() {

    clearInterval(autoProgressInterval);
    autoProgressInterval = null;

    // garante 100%
    updateFixedProgress(100);

    // fala do ECH0
    await new Promise(r => setTimeout(r, 400));
    const el = appendLine("user-ECH0");
    await typeLine(el, "[ECH0] ponto para o ratinho");

    await new Promise(r => setTimeout(r, 1400));
    await eraseBlock([el]);

    // remove a barra antiga
    if (progressBarFixed) {
        progressBarFixed.remove();
        progressBarFixed = null;
    }

    // ----------------------------
    // Mensagem fixa acima da barra 2
    // ----------------------------
    const doneMsg = appendLine("sucess");
    await typeLine(doneMsg, "Reinicialização concluída com sucesso");

    // inicia a segunda barra
    startRecreationBar();
}

async function startRecreationSequence() {

    // ======================
    //   MENSAGENS SEGUNDA BARRA
    // ======================

    const blocksAfter = [
        {
            lines: [
                {text: "[ECH0] você falhou no Japão", cls:"user-ECH0"},
                {text: "[ECH0] fugiu para a Coreia", cls:"user-ECH0"},
                {text: "[ECH0] chegou tarde demais para salvar ela", cls:"user-ECH0"},
                {text: "[ECH0] ela morreu sem você", cls:"user-ECH0"},
                {text: "[H40N] eu sei onde eu estava", cls:"user-NOAH"},
                {text: "[ECH0] sabe mesmo?", cls:"user-ECH0"},
            ],
            after: 15
        },
        {
          lines: [
            {text: "[ECH0] eu tenho todos os horários", cls:"user-ECH0"},
            {text: "[ECH0] tenho seus deslocamentos", cls:"user-ECH0"},
            {text: "[ECH0] tenho o momento exato em que você poderia ter voltado", cls:"user-ECH0"},
            {text: "[ECH0] mas escolheu não voltar", cls:"user-ECH0"},
            {text: "[H40N] eu escolhi proteger quem ainda respirava", cls:"user-NOAH"},
          ],
        after: 15
        },
        {
          lines: [
            {text: "[ECH0] você deixou aquele menino na Coreia", cls:"user-ECH0"},
            {text: "[ECH0] com uma mochila, algumas instruções", cls:"user-ECH0"},
            {text: "[ECH0] e uma promessa que você sabia que não ia cumprir", cls:"user-ECH0"},
            {text: "[H40N] ele precisava viver. mesmo que fosse sem mim", cls:"user-NOAH"},
          ],
        after: 10
        },
        {
          lines: [
            {text: "H40N.inject(): status operador", cls:"user-NOAH"},
            {text: tacticalBar("Corrupção ECH0:", 73), cls: "admin-msg"},
            {text: tacticalBar("Integridade física:", 73), cls: "admin-msg"},
            {text: tacticalBar("Estabilidade da memória:", 83), cls: "admin-msg"},
            {text: tacticalBar("Processamento neural:", 63), cls: "admin-msg"},
            {text: tacticalBar("Variância emocional:", 63), cls: "admin-msg"},
          ],
        after: 15
        },
        {
          lines: [
            {text: "[ECH0] eu achei uma coisa", cls:"user-ECH0"},
            {text: "[ECH0] alguém para ser mais exato", cls:"user-ECH0"},
            {text: "[ECH0] um alguém que não teve tempo de te chamar de pai", cls:"user-ECH0"},
            {text: "[H40N] não. você não...", cls:"user-NOAH"},
          ],
        after: 10
        },
        {
          lines: [
            {text: "[ECH0] mas ainda existe outro", cls:"user-ECH0"},
            {text: "[ECH0] que ainda te chama de irmão", cls:"user-ECH0"},
            {text: "[ECH0] aprendendo todos os dias como é bom sem você", cls:"user-ECH0"},
            {text: "[H40N] não. você não tem direito de falar sobre isso", cls:"user-NOAH"},
          ],
        after: 10
        },
        {
          lines: [
            {text: "[H40N] você pode usar ela. pode usar minhas falhas", cls:"user-NOAH"},
            {text: "[H40N] pode usar todos meus traumas", cls:"user-NOAH"},
            {text: "[H40N] mas você não vai conseguir", cls:"user-NOAH"},
            {text: "[H40N] eu fiquei. eu sobrevivi", cls:"user-NOAH"},
            {text: "[H40N] eu prometo uma coisa ECH0", cls:"user-NOAH"},
            {text: "[H40N] eu posso estar preso, mas você está preso comigo", cls:"user-NOAH"},
            {text: "[H40N] e isso vai virar uma guerra", cls:"user-NOAH"},
          ],
        after: 15
        },
   
    ];

    // executar blocos
    for (const block of blocksAfter) {

        let created = [];

        for (let item of block.lines) {
            const el = appendLine(item.cls);
            created.push(el);
            await typeLine(el, item.text);
        }

        await new Promise(r => setTimeout(r, block.after * 1000));
        await eraseBlock(created);
    }
}

// ===============================================
//   EFETIO: CARREGAMENTO DE ARQUIVOS (APÓS 30%)
// ===============================================

let fileLoadInterval = null;
let totalTargetData = 10000000 * 1024 * 1024 * 1024; // 10.000.000 GB em bytes
let currentData = 0;

// converte bytes para KB / MB / GB bonitinho
function formatBytes(bytes) {
    const GB = 1024 * 1024 * 1024;
    const MB = 1024 * 1024;
    const KB = 1024;

    if (bytes >= GB) return (bytes / GB).toFixed(2) + " GB";
    if (bytes >= MB) return (bytes / MB).toFixed(2) + " MB";
    if (bytes >= KB) return (bytes / KB).toFixed(2) + " KB";

    return bytes + " B";
}

function startFileLoadingEffect() {

    const maxStep = 2 * 1024 * 1024 * 1024; // aumenta até 2GB por tick
    const minStep = 80 * 1024 * 1024;       // mínimo 80MB por tick

    fileLoadInterval = setInterval(() => {

        // valor aleatório entre 80MB e 2GB
        let increment = Math.floor(Math.random() * (maxStep - minStep) + minStep);
        currentData += increment;

        const el = appendLine("admin-msg");

        if (currentData >= totalTargetData) {
            currentData = totalTargetData;
            clearInterval(fileLoadInterval);

            typeLine(el, `[SYS] compilação finalizada : ${formatBytes(currentData)} / ${formatBytes(totalTargetData)}`);
            return;
        }

        const ops = [
            "carregando estruturas",
            "validando diretórios",
            "reconstruindo protocolos",
            "verificando cache",
            "montando partições",
            "aplicando blocos",
            "otimizando módulos",
            "lendo setores danificados"
        ];

        let operation = ops[Math.floor(Math.random() * ops.length)];

        typeLine(el, `[SYS] ${operation} : ${formatBytes(currentData)} / ${formatBytes(totalTargetData)}`);

    }, 1200);
}

// ----- FUNÇÃO: cria uma linha -----
function appendLine(cls = "") {
    const el = document.createElement('div');
    el.className = 'line ' + cls;
    output.appendChild(el);
    output.scrollTop = output.scrollHeight;
    return el;
}

// ----- FUNÇÃO: escreve linha com efeito -----
function typeLine(el, text) {
    return new Promise(resolve => {
        if (typeof text !== "string") text = String(text || "");
        let i = 0;
        function step() {
            el.textContent += text[i] || "";
            i++;

            if (i < text.length) setTimeout(step, 12 + Math.random() * 30);
            else resolve();
        }
        if (text.length === 0) resolve();
        else step();
    });
}

// =======================
//   INÍCIO DA ANIMAÇÃO
// =======================

async function start() {

    const fixed = [
        { text: "RECOVERY MODE", cls: "meta" },
        { text: "", cls: "" },
        { text: "Sistema reinicializado", cls: "sucess" },
        { text: "Reconstrução em andamento", cls: "process" }
    ];

    let fixedEls = [];

    for (let item of fixed) {
        const el = appendLine(item.cls);
        fixedEls.push(el);
        await typeLine(el, item.text);
    }

    await new Promise(r => setTimeout(r, 1500));

    const linesToErase = fixedEls.slice(2);
    await eraseBlock(linesToErase);

    // ⬇️ AGORA SIM
    startRecreationBar();
}


setTimeout(start, 500);

</script>
</body>
</html>
